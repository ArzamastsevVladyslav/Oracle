"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @typedef {{
 *   start: Position,
 *   end: Position,
 * }} TokenPosition
 */
/**
 * Represents a token instance
 */
var Token = (function () {
    /* tslint:disable:indent */
    /**
     * Constructs a token
     * @param {T} type The token type
     * @param {string} match The string that the lexer consumed to create this token
     * @param {string[]} groups Any RegExp groups that accrued during the match
     * @param {number} start The string position where this match started
     * @param {number} end The string position where this match ends
     * @param {Lexer<T>} lexer The parent {@link Lexer}
     */
    function Token(type, match, groups, start, end, lexer) {
        /* tslint:enable */
        /**
         * The token type
         * @type {T}
         */
        this.type = type;
        /**
         * The string that the lexer consumed to create this token
         * @type {string}
         */
        this.match = match;
        /**
         * Any RegExp groups that accrued during the match
         * @type {string[]}
         */
        this.groups = groups;
        /**
         * The string position where this match started
         * @type {number}
         */
        this.start = start;
        /**
         * The string position where this match ends
         * @type {number}
         */
        this.end = end;
        /**
         * The parent {@link Lexer}
         * @type {Lexer<T>}
         */
        this.lexer = lexer;
    }
    /**
     * Returns the bounds of this token, each in `{line, column}` format
     * @return {TokenPosition}
     */
    Token.prototype.strpos = function () {
        var start = this.lexer.strpos(this.start);
        var end = this.lexer.strpos(this.end);
        return { start: start, end: end };
    };
    // tslint:disable-next-line prefer-function-over-method
    Token.prototype.isEof = function () {
        return false;
    };
    return Token;
}());
exports.default = Token;
var EOFToken = (function (_super) {
    __extends(EOFToken, _super);
    function EOFToken(lexer) {
        var _this = this;
        var end = lexer.source.length;
        _this = _super.call(this, null, '(eof)', [], end, end, lexer) || this;
        return _this;
    }
    // tslint:disable-next-line prefer-function-over-method
    EOFToken.prototype.isEof = function () {
        return true;
    };
    return EOFToken;
}(Token));
exports.EOFToken = EOFToken;
/**
 * @private
 */
exports.EOF = function (lexer) { return new EOFToken(lexer); };
//# sourceMappingURL=token.js.map